diff --git a/Dockerfile b/Dockerfile
new file mode 100644
index 0000000..0a8f2d1
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,90 @@
+FROM debian:stable-slim AS mcrcon-builder
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+RUN set -eux; \
+    apt-get update; \
+    apt-get install -y --no-install-recommends \
+      ca-certificates \
+      git \
+      build-essential \
+    ; \
+    rm -rf /var/lib/apt/lists/*
+
+RUN set -eux; \
+    git clone --depth 1 https://github.com/Tiiffi/mcrcon /tmp/mcrcon; \
+    make -C /tmp/mcrcon; \
+    install -m 0755 /tmp/mcrcon/mcrcon /usr/local/bin/mcrcon
+
+
+FROM debian:stable-slim
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# NOTE:
+# - Do NOT EXPOSE ports here (user asked to avoid fixing ports in Dockerfile).
+# - BDS is officially supported on Ubuntu 22.04+; Debian stable-slim may need extra libs depending on BDS version.
+#   Entrypoint will ldd-check and show missing libs clearly.
+RUN set -eux; \
+    apt-get update; \
+    apt-get install -y --no-install-recommends \
+      bash \
+      ca-certificates \
+      curl \
+      jq \
+      unzip \
+      rsync \
+      tini \
+      gosu \
+      procps \
+      libstdc++6 \
+      libgcc-s1 \
+      libcurl4 \
+      libssl3 \
+    ; \
+    rm -rf /var/lib/apt/lists/*
+
+# MinIO client (mc) for S3 sync parity with your Java image
+ARG TARGETARCH
+RUN set -eux; \
+    case "${TARGETARCH:-amd64}" in \
+      amd64) MC_ARCH="amd64" ;; \
+      arm64) MC_ARCH="arm64" ;; \
+      *) echo "Unsupported TARGETARCH=${TARGETARCH} (use amd64/arm64)"; exit 1 ;; \
+    esac; \
+    curl -fsSL "https://dl.min.io/client/mc/release/linux-${MC_ARCH}/mc" -o /usr/local/bin/mc; \
+    chmod +x /usr/local/bin/mc; \
+    /usr/local/bin/mc --version
+
+# mcrcon (RCON client) - default enabled in entrypoint (your request)
+COPY --from=mcrcon-builder /usr/local/bin/mcrcon /usr/local/bin/mcrcon
+
+# Entrypoint
+COPY docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh
+RUN chmod +x /usr/local/bin/docker-entrypoint.sh
+
+WORKDIR /data
+VOLUME ["/data"]
+
+ENTRYPOINT ["/usr/bin/tini","-g","--","/usr/local/bin/docker-entrypoint.sh"]
+CMD []
diff --git a/docker-entrypoint.sh b/docker-entrypoint.sh
new file mode 100755
index 0000000..6b3b4c4
--- /dev/null
+++ b/docker-entrypoint.sh
@@ -0,0 +1,478 @@
+#!/usr/bin/env bash
+set -Eeuo pipefail
+
+ts() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }
+log() { echo "[$(ts)] [$1] $2"; }
+die() { log ERROR "$1"; exit 1; }
+
+is_true() {
+  case "${1,,}" in
+    1|true|yes|y|on) return 0 ;;
+    *) return 1 ;;
+  esac
+}
+
+trim_ws() {
+  local s="$1"
+  s="${s#"${s%%[![:space:]]*}"}"
+  s="${s%"${s##*[![:space:]]}"}"
+  printf '%s' "$s"
+}
+
+validate_port() {
+  local name="$1" val="$2"
+  [[ -n "$val" ]] || return 0
+  [[ "$val" =~ ^[0-9]+$ ]] || die "${name} must be a number (got: ${val})"
+  (( val >= 1 && val <= 65535 )) || die "${name} must be 1-65535 (got: ${val})"
+}
+
+# ============================================================
+# Defaults (keep "non-overriding by default" for server.properties)
+#  - We only write a property if its ENV is non-empty.
+#  - EXCEPTION: RCON defaults to enabled (your request) and we always enforce it when enabled.
+# ============================================================
+
+: "${DATA_DIR:=/data}"
+: "${UID:=1000}"
+: "${GID:=1000}"
+
+# Required
+: "${EULA:=}"
+
+# Bedrock server version
+# - "latest": scrape official download page
+# - or explicit like "1.21.130.4" (zip name usually matches)
+: "${VERSION:=latest}"
+: "${BDS_DOWNLOAD_URL:=}"
+
+# Runtime
+: "${READY_DELAY:=5}"
+: "${FIX_OWNERSHIP:=true}"
+
+# RCON (DEFAULT ENABLED)
+: "${ENABLE_RCON:=true}"
+: "${RCON_HOST:=127.0.0.1}"
+: "${RCON_PORT:=19134}"     # keep separate from game port; override if you want
+: "${RCON_PASSWORD:=}"      # REQUIRED when ENABLE_RCON=true
+
+# S3 (optional)
+: "${S3_ENDPOINT:=}"
+: "${S3_ACCESS_KEY:=}"
+: "${S3_SECRET_KEY:=}"
+
+# Behavior packs
+: "${BEHAVIORPACKS_ENABLED:=true}"
+: "${BEHAVIORPACKS_S3_BUCKET:=}"
+: "${BEHAVIORPACKS_S3_PREFIX:=behavior_packs/latest}"
+: "${BEHAVIORPACKS_SYNC_ONCE:=true}"
+: "${BEHAVIORPACKS_REMOVE_EXTRA:=true}"
+: "${INPUT_BEHAVIORPACKS_DIR:=/behavior_packs}"
+
+# Resource packs
+: "${RESOURCEPACKS_ENABLED:=true}"
+: "${RESOURCEPACKS_S3_BUCKET:=}"
+: "${RESOURCEPACKS_S3_PREFIX:=resource_packs/latest}"
+: "${RESOURCEPACKS_SYNC_ONCE:=true}"
+: "${RESOURCEPACKS_REMOVE_EXTRA:=true}"
+: "${INPUT_RESOURCEPACKS_DIR:=/resource_packs}"
+
+# Worlds (zip import)
+: "${WORLD_S3_BUCKET:=}"
+: "${WORLD_S3_KEY:=}"
+: "${WORLD_INSTALL_ONCE:=true}"
+
+# Extra server.properties overrides: "key=value,key=value"
+: "${BDS_PROPERTIES:=}"
+
+# Graceful shutdown
+: "${RCON_RETRIES:=5}"
+: "${RCON_RETRY_DELAY:=1}"
+: "${RCON_TIMEOUT:=5}"
+: "${SHUTDOWN_WAIT_TIMEOUT:=60}"
+: "${SHUTDOWN_TERM_WAIT:=10}"
+
+# Lock on ephemeral FS to prevent double stop (preStop + trap)
+: "${RCON_STOP_LOCK:=/tmp/.rcon-stop.lockdir}"
+RCON_STOP_IN_PROGRESS=0
+RCON_STOP_RESULT=1
+SERVER_PID=""
+
+# ============================================================
+# Bedrock: env -> server.properties mapping
+# (Write only when ENV is set non-empty)
+# ============================================================
+declare -A PROP_MAP=(
+  [SERVER_NAME]="server-name"
+  [GAMEMODE]="gamemode"
+  [FORCE_GAMEMODE]="force-gamemode"
+  [DIFFICULTY]="difficulty"
+  [ALLOW_CHEATS]="allow-cheats"
+  [MAX_PLAYERS]="max-players"
+  [ONLINE_MODE]="online-mode"
+  [ALLOW_LIST]="allow-list"
+  [SERVER_PORT]="server-port"
+  [SERVER_PORTV6]="server-portv6"
+  [LEVEL_NAME]="level-name"
+  [LEVEL_SEED]="level-seed"
+  [LEVEL_TYPE]="level-type"
+  [DEFAULT_PLAYER_PERMISSION_LEVEL]="default-player-permission-level"
+  [TEXTUREPACK_REQUIRED]="texturepack-required"
+  [VIEW_DISTANCE]="view-distance"
+  [TICK_DISTANCE]="tick-distance"
+  [MAX_THREADS]="max-threads"
+  [PLAYER_IDLE_TIMEOUT]="player-idle-timeout"
+  [CHAT_RESTRICTION]="chat-restriction"
+  [ENABLE_LAN_VISIBILITY]="enable-lan-visibility"
+  [SERVER_PUBLIC_IP]="server-public-ip"
+)
+
+preflight() {
+  log INFO "Preflight checks..."
+
+  [[ -d "${DATA_DIR}" ]] || die "${DATA_DIR} does not exist"
+  touch "${DATA_DIR}/.write_test" 2>/dev/null || die "${DATA_DIR} is not writable"
+  rm -f "${DATA_DIR}/.write_test"
+
+  [[ -n "${EULA:-}" ]] || die "EULA is not set (set EULA=true)"
+  [[ "${EULA}" == "true" ]] || die "EULA must be true"
+
+  [[ "${UID}" =~ ^[0-9]+$ ]] || die "UID must be numeric"
+  [[ "${GID}" =~ ^[0-9]+$ ]] || die "GID must be numeric"
+
+  # RCON default enabled -> password required
+  if is_true "${ENABLE_RCON}"; then
+    [[ -n "${RCON_PASSWORD}" ]] || die "ENABLE_RCON=true but RCON_PASSWORD is empty"
+    validate_port "RCON_PORT" "${RCON_PORT}"
+  fi
+
+  # If user overrides ports via env, validate them
+  validate_port "SERVER_PORT" "${SERVER_PORT:-}"
+  validate_port "SERVER_PORTV6" "${SERVER_PORTV6:-}"
+
+  rm -f "${DATA_DIR}/.ready" || true
+  log INFO "Preflight OK"
+}
+
+install_dirs() {
+  log INFO "Preparing directory structure"
+  mkdir -p \
+    "${DATA_DIR}/logs" \
+    "${DATA_DIR}/worlds"
+
+  # optional input dirs (mount points)
+  mkdir -p "${INPUT_BEHAVIORPACKS_DIR}" "${INPUT_RESOURCEPACKS_DIR}" || true
+}
+
+install_eula() {
+  log INFO "Handling EULA"
+  echo "eula=true" > "${DATA_DIR}/eula.txt"
+}
+
+mc_configure() {
+  [[ -n "${S3_ENDPOINT}" ]] || die "S3_ENDPOINT is required"
+  [[ -n "${S3_ACCESS_KEY}" ]] || die "S3_ACCESS_KEY is required"
+  [[ -n "${S3_SECRET_KEY}" ]] || die "S3_SECRET_KEY is required"
+  mc alias set s3 "${S3_ENDPOINT}" "${S3_ACCESS_KEY}" "${S3_SECRET_KEY}" >/dev/null \
+    || die "Failed to configure MinIO client"
+}
+
+activate_dir_atomic() {
+  local src="$1" dst="$2" name="$3"
+  [[ -d "$src" ]] || { log INFO "No ${name} directory found (${src}), skipping"; return 0; }
+
+  local parent base staging backup
+  parent="$(dirname "$dst")"
+  base="$(basename "$dst")"
+  staging="${parent}/.${base}.staging"
+  backup="${parent}/.${base}.old"
+
+  log INFO "Activating ${name} (atomic) (${src} -> ${dst})"
+  rm -rf "$staging"
+  mkdir -p "$staging"
+  rsync -a --delete "$src"/ "$staging"/
+
+  if [[ -d "$dst" ]]; then
+    rm -rf "$backup"
+    mv "$dst" "$backup"
+  fi
+  mv "$staging" "$dst"
+  rm -rf "$backup"
+}
+
+install_behaviorpacks() {
+  is_true "${BEHAVIORPACKS_ENABLED}" || { log INFO "Behavior packs disabled"; return 0; }
+  [[ -n "${BEHAVIORPACKS_S3_BUCKET}" ]] || { log INFO "BEHAVIORPACKS_S3_BUCKET not set, skipping"; return 0; }
+
+  mc_configure
+  local dst="${INPUT_BEHAVIORPACKS_DIR}"
+  mkdir -p "$dst"
+
+  if is_true "${BEHAVIORPACKS_SYNC_ONCE}" && find "$dst" -mindepth 1 -maxdepth 1 -print -quit | grep -q . \
+    && ! is_true "${BEHAVIORPACKS_REMOVE_EXTRA}"; then
+    log INFO "Behavior packs already present, skipping sync (SYNC_ONCE=true)"
+    return 0
+  fi
+
+  local remove=""
+  is_true "${BEHAVIORPACKS_REMOVE_EXTRA}" && remove="--remove"
+  log INFO "Syncing behavior packs from s3://${BEHAVIORPACKS_S3_BUCKET}/${BEHAVIORPACKS_S3_PREFIX}"
+  mc mirror --overwrite ${remove} "s3/${BEHAVIORPACKS_S3_BUCKET}/${BEHAVIORPACKS_S3_PREFIX}" "$dst" \
+    || die "Failed to sync behavior packs"
+}
+
+activate_behaviorpacks() {
+  activate_dir_atomic "${INPUT_BEHAVIORPACKS_DIR}" "${DATA_DIR}/behavior_packs" "behavior_packs"
+}
+
+install_resourcepacks() {
+  is_true "${RESOURCEPACKS_ENABLED}" || { log INFO "Resource packs disabled"; return 0; }
+  [[ -n "${RESOURCEPACKS_S3_BUCKET}" ]] || { log INFO "RESOURCEPACKS_S3_BUCKET not set, skipping"; return 0; }
+
+  mc_configure
+  local dst="${INPUT_RESOURCEPACKS_DIR}"
+  mkdir -p "$dst"
+
+  if is_true "${RESOURCEPACKS_SYNC_ONCE}" && find "$dst" -mindepth 1 -maxdepth 1 -print -quit | grep -q . \
+    && ! is_true "${RESOURCEPACKS_REMOVE_EXTRA}"; then
+    log INFO "Resource packs already present, skipping sync (SYNC_ONCE=true)"
+    return 0
+  fi
+
+  local remove=""
+  is_true "${RESOURCEPACKS_REMOVE_EXTRA}" && remove="--remove"
+  log INFO "Syncing resource packs from s3://${RESOURCEPACKS_S3_BUCKET}/${RESOURCEPACKS_S3_PREFIX}"
+  mc mirror --overwrite ${remove} "s3/${RESOURCEPACKS_S3_BUCKET}/${RESOURCEPACKS_S3_PREFIX}" "$dst" \
+    || die "Failed to sync resource packs"
+}
+
+activate_resourcepacks() {
+  activate_dir_atomic "${INPUT_RESOURCEPACKS_DIR}" "${DATA_DIR}/resource_packs" "resource_packs"
+}
+
+resolve_bds_download_url() {
+  if [[ -n "${BDS_DOWNLOAD_URL}" ]]; then
+    echo "${BDS_DOWNLOAD_URL}"
+    return 0
+  fi
+
+  if [[ "${VERSION}" != "latest" ]]; then
+    # Common pattern
+    echo "https://minecraft.azureedge.net/bin-linux/bedrock-server-${VERSION}.zip"
+    return 0
+  fi
+
+  # Scrape official download page for Linux server zip
+  # Typical link: https://minecraft.azureedge.net/bin-linux/bedrock-server-<ver>.zip
+  local page url
+  page="$(curl -fsSL "https://www.minecraft.net/en-us/download/server/bedrock")" \
+    || die "Failed to fetch official Bedrock server download page"
+  url="$(printf '%s' "$page" | grep -Eo 'https://minecraft\.azureedge\.net/bin-linux/bedrock-server-[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\.zip' | head -n1 || true)"
+  [[ -n "$url" ]] || die "Failed to find Linux bedrock-server zip URL on the download page"
+  echo "$url"
+}
+
+current_installed_version() {
+  [[ -f "${DATA_DIR}/.bds-version" ]] && cat "${DATA_DIR}/.bds-version" || true
+}
+
+install_bds() {
+  log INFO "Resolving Bedrock Dedicated Server (VERSION=${VERSION})"
+
+  local url want_version installed_version
+  url="$(resolve_bds_download_url)"
+
+  want_version="${VERSION}"
+  if [[ "${VERSION}" == "latest" ]]; then
+    # parse version from url
+    want_version="$(basename "$url" | sed -E 's/^bedrock-server-([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)\.zip$/\1/')"
+  fi
+
+  installed_version="$(current_installed_version)"
+  if [[ -x "${DATA_DIR}/bedrock_server" && -n "$installed_version" && "$installed_version" == "$want_version" ]]; then
+    log INFO "BDS already installed (version=${installed_version}), skipping"
+    return 0
+  fi
+
+  log INFO "Downloading BDS: ${url}"
+  local tmp_zip tmp_dir
+  tmp_zip="$(mktemp /tmp/bds.XXXXXX.zip)"
+  tmp_dir="$(mktemp -d /tmp/bds.XXXXXX.dir)"
+  rm -rf "$tmp_dir" && mkdir -p "$tmp_dir"
+
+  curl -fL "$url" -o "$tmp_zip" || die "Failed to download BDS zip"
+  unzip -q "$tmp_zip" -d "$tmp_dir" || die "Failed to unzip BDS"
+
+  # Update core server files, but do not clobber user state by default
+  # - preserve worlds/, server.properties, allowlist.json, permissions.json
+  log INFO "Installing BDS into ${DATA_DIR} (preserving worlds/ and key configs)"
+  rsync -a \
+    --exclude 'worlds/' \
+    --exclude 'server.properties' \
+    --exclude 'allowlist.json' \
+    --exclude 'permissions.json' \
+    "$tmp_dir"/ "$DATA_DIR"/
+
+  # Seed config files if absent
+  [[ -f "${DATA_DIR}/server.properties" ]] || cp -a "$tmp_dir/server.properties" "${DATA_DIR}/server.properties"
+  [[ -f "${DATA_DIR}/allowlist.json" ]] || cp -a "$tmp_dir/allowlist.json" "${DATA_DIR}/allowlist.json" 2>/dev/null || true
+  [[ -f "${DATA_DIR}/permissions.json" ]] || cp -a "$tmp_dir/permissions.json" "${DATA_DIR}/permissions.json" 2>/dev/null || true
+
+  chmod +x "${DATA_DIR}/bedrock_server" || true
+
+  echo "$want_version" > "${DATA_DIR}/.bds-version"
+
+  rm -f "$tmp_zip"
+  rm -rf "$tmp_dir"
+
+  log INFO "BDS installed (version=${want_version})"
+}
+
+ldd_check() {
+  local bin="${DATA_DIR}/bedrock_server"
+  [[ -x "$bin" ]] || die "bedrock_server not found/executable at ${bin}"
+  local missing
+  missing="$(ldd "$bin" 2>/dev/null | awk '/not found/ {print $1}' | tr '\n' ' ' | sed 's/[[:space:]]*$//')"
+  if [[ -n "$missing" ]]; then
+    die "Missing shared libraries for bedrock_server: ${missing}. (Debian stable-slim may require extra libs depending on BDS build.)"
+  fi
+}
+
+set_prop() {
+  local key="$1" value="$2" file="${DATA_DIR}/server.properties"
+  touch "$file"
+  if grep -qE "^${key}=" "$file"; then
+    sed -i "s|^${key}=.*|${key}=${value}|" "$file"
+  else
+    printf "%s=%s\n" "$key" "$value" >> "$file"
+  fi
+}
+
+apply_server_properties_from_env() {
+  local file="${DATA_DIR}/server.properties"
+  [[ -f "$file" ]] || die "server.properties not found at ${file}"
+
+  log INFO "Applying server.properties overrides from ENV (only non-empty vars)"
+
+  # 1) Mapped ENV -> property keys
+  for env_key in "${!PROP_MAP[@]}"; do
+    local prop_key="${PROP_MAP[$env_key]}"
+    local env_val="${!env_key:-}"
+    env_val="$(trim_ws "$env_val")"
+    [[ -z "$env_val" ]] && continue
+    set_prop "$prop_key" "$env_val"
+    log INFO "Applied: ${prop_key}=${env_val}"
+  done
+
+  # 2) Extra key=value list (BDS_PROPERTIES)
+  if [[ -n "${BDS_PROPERTIES:-}" ]]; then
+    local -a items
+    IFS=',' read -ra items <<< "${BDS_PROPERTIES}"
+    local it k v
+    for it in "${items[@]}"; do
+      it="$(trim_ws "$it")"
+      [[ -z "$it" ]] && continue
+      [[ "$it" == *"="* ]] || die "Invalid BDS_PROPERTIES item: '${it}' (expected key=value)"
+      k="$(trim_ws "${it%%=*}")"
+      v="$(trim_ws "${it#*=}")"
+      [[ -n "$k" ]] || die "Invalid BDS_PROPERTIES item: '${it}' (empty key)"
+      set_prop "$k" "$v"
+      log INFO "Applied(extra): ${k}=${v}"
+    done
+  fi
+
+  # 3) RCON policy (default enabled)
+  if is_true "${ENABLE_RCON}"; then
+    set_prop "enable-rcon" "true"
+    set_prop "rcon.port" "${RCON_PORT}"
+    set_prop "rcon.password" "${RCON_PASSWORD}"
+    log INFO "RCON enabled (enable-rcon=true, rcon.port=${RCON_PORT})"
+  else
+    set_prop "enable-rcon" "false"
+    log INFO "RCON disabled (enable-rcon=false)"
+  fi
+}
+
+install_world_zip_from_s3() {
+  # Optional: import a worlds zip from S3 on first run
+  [[ -n "${WORLD_S3_BUCKET}" && -n "${WORLD_S3_KEY}" ]] || { log INFO "WORLD_S3_BUCKET/KEY not set, skipping world import"; return 0; }
+
+  if is_true "${WORLD_INSTALL_ONCE}"; then
+    if find "${DATA_DIR}/worlds" -mindepth 1 -maxdepth 1 -print -quit 2>/dev/null | grep -q .; then
+      log INFO "Worlds already exist, skipping world import (WORLD_INSTALL_ONCE=true)"
+      return 0
+    fi
+  fi
+
+  mc_configure
+  local tmp_zip="/tmp/worlds.zip"
+  rm -f "$tmp_zip" || true
+  log INFO "Downloading worlds zip from s3://${WORLD_S3_BUCKET}/${WORLD_S3_KEY}"
+  mc cp "s3/${WORLD_S3_BUCKET}/${WORLD_S3_KEY}" "$tmp_zip" || die "Failed to download worlds zip"
+
+  log INFO "Extracting worlds zip into ${DATA_DIR}/worlds"
+  mkdir -p "${DATA_DIR}/worlds"
+  unzip -q "$tmp_zip" -d "${DATA_DIR}/worlds" || die "Failed to unzip worlds archive"
+  rm -f "$tmp_zip"
+}
+
+cleanup_rcon_lock_on_boot() {
+  rm -rf "${RCON_STOP_LOCK}" 2>/dev/null || true
+}
+
+acquire_rcon_stop_lock() {
+  mkdir "${RCON_STOP_LOCK}" 2>/dev/null
+}
+
+rcon_exec() {
+  local cmd="$*"
+  local attempt=1
+
+  if ! is_true "${ENABLE_RCON}"; then
+    log INFO "RCON disabled, skip: ${cmd}"
+    return 1
+  fi
+  [[ -n "${RCON_PASSWORD}" ]] || return 1
+
+  while true; do
+    if timeout "${RCON_TIMEOUT}" \
+      mcrcon -H "${RCON_HOST}" -P "${RCON_PORT}" -p "${RCON_PASSWORD}" "${cmd}"; then
+      return 0
+    fi
+    if (( attempt >= RCON_RETRIES )); then
+      log ERROR "RCON failed after ${attempt} attempts: ${cmd}"
+      return 1
+    fi
+    log WARN "RCON failed (attempt ${attempt}/${RCON_RETRIES}), retrying: ${cmd}"
+    attempt=$((attempt + 1))
+    sleep "${RCON_RETRY_DELAY}"
+  done
+}
+
+rcon_stop_once() {
+  if [[ "${RCON_STOP_IN_PROGRESS}" == "1" ]]; then
+    return "${RCON_STOP_RESULT}"
+  fi
+  if ! acquire_rcon_stop_lock; then
+    log INFO "rcon_stop already running (lock exists), skipping"
+    return "${RCON_STOP_RESULT}"
+  fi
+  RCON_STOP_IN_PROGRESS=1
+
+  log INFO "[shutdown] rcon: stop"
+  if rcon_exec "stop"; then
+    RCON_STOP_RESULT=0
+  else
+    RCON_STOP_RESULT=1
+  fi
+  return "${RCON_STOP_RESULT}"
+}
+
+wait_for_server_exit() {
+  local timeout="$1" elapsed=0
+  while [[ -n "${SERVER_PID:-}" ]] && kill -0 "${SERVER_PID}" 2>/dev/null; do
+    if (( elapsed >= timeout )); then
+      return 1
+    fi
+    sleep 1
+    elapsed=$((elapsed + 1))
+  done
+  return 0
+}
+
+graceful_shutdown() {
+  log INFO "[shutdown] begin"
+
+  # Try RCON stop first (default enabled)
+  if rcon_stop_once; then
+    log INFO "[shutdown] rcon stop succeeded"
+  else
+    log WARN "[shutdown] rcon stop failed/unavailable, sending TERM to server process"
+    if [[ -n "${SERVER_PID:-}" ]] && kill -0 "${SERVER_PID}" 2>/dev/null; then
+      kill -TERM "${SERVER_PID}" 2>/dev/null || true
+    fi
+  fi
+
+  log INFO "[shutdown] waiting for server process (timeout: ${SHUTDOWN_WAIT_TIMEOUT}s)"
+  if wait_for_server_exit "${SHUTDOWN_WAIT_TIMEOUT}"; then
+    log INFO "[shutdown] server exited"
+    exit 0
+  fi
+
+  log WARN "[shutdown] timeout exceeded, sending TERM"
+  if [[ -n "${SERVER_PID:-}" ]] && kill -0 "${SERVER_PID}" 2>/dev/null; then
+    kill -TERM "${SERVER_PID}" 2>/dev/null || true
+  fi
+
+  if wait_for_server_exit "${SHUTDOWN_TERM_WAIT}"; then
+    log INFO "[shutdown] server exited after TERM"
+    exit 0
+  fi
+
+  log WARN "[shutdown] forcing kill"
+  if [[ -n "${SERVER_PID:-}" ]] && kill -0 "${SERVER_PID}" 2>/dev/null; then
+    kill -KILL "${SERVER_PID}" 2>/dev/null || true
+  fi
+  exit 0
+}
+
+trap 'graceful_shutdown' TERM INT QUIT
+
+run_server() {
+  cleanup_rcon_lock_on_boot
+
+  ( cd "${DATA_DIR}" && \
+    export LD_LIBRARY_PATH="${DATA_DIR}:${LD_LIBRARY_PATH:-}" && \
+    ./bedrock_server \
+  ) &
+
+  SERVER_PID=$!
+  wait "$SERVER_PID"
+}
+
+fix_ownership_if_needed() {
+  if [[ "$(id -u)" -ne 0 ]]; then
+    return 0
+  fi
+  if ! is_true "${FIX_OWNERSHIP}"; then
+    return 0
+  fi
+  if [[ "${UID}" == "0" && "${GID}" == "0" ]]; then
+    return 0
+  fi
+  log INFO "Fixing ownership: ${DATA_DIR} -> ${UID}:${GID}"
+  chown -R "${UID}:${GID}" "${DATA_DIR}" || die "chown failed (set FIX_OWNERSHIP=false to skip)"
+}
+
+install() {
+  log INFO "Install phase start"
+  install_dirs
+  install_eula
+  install_bds
+  ldd_check
+
+  install_world_zip_from_s3
+
+  install_behaviorpacks
+  activate_behaviorpacks
+  install_resourcepacks
+  activate_resourcepacks
+
+  apply_server_properties_from_env
+  log INFO "Install phase completed"
+}
+
+runtime() {
+  log INFO "Starting runtime"
+  touch "${DATA_DIR}/.ready" || true
+  sleep "${READY_DELAY}" || true
+
+  # drop privileges if root
+  if [[ "$(id -u)" -eq 0 && ( "${UID}" != "0" || "${GID}" != "0" ) ]]; then
+    log INFO "Dropping privileges to ${UID}:${GID}"
+    exec gosu "${UID}:${GID}" /usr/local/bin/docker-entrypoint.sh run
+  fi
+
+  run_server
+}
+
+case "${1:-}" in
+  rcon)
+    shift
+    rcon_exec "$@"
+    exit $?
+    ;;
+  rcon-stop)
+    rcon_stop_once || true
+    exit 0
+    ;;
+  run)
+    shift || true
+    # continue
+    ;;
+  "" )
+    # default
+    ;;
+  * )
+    # allow custom commands
+    exec "$@"
+    ;;
+esac
+
+main() {
+  log INFO "Minecraft Bedrock Runtime Booting..."
+  preflight
+  fix_ownership_if_needed
+  install
+  runtime
+}
+
+main "$@"

